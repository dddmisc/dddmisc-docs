{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DDDMisc","text":"<p>DDDMisc is a set of libraries that provide basic solutions for implementing domain-driven design methods in the Python programming language.</p> <p>The development of libraries is in alpha version. The public API is not guaranteed to be backward compatible between minor versions of packages.</p>"},{"location":"#libraries","title":"Libraries","text":"<ul> <li><code>dddmisc-core</code>- this package provides the core interfaces and     types for dddmisc packages family;</li> <li><code>dddmisc-domain</code> - this package provides implementation domain's objects classes;</li> <li><code>dddmisc-messagebus</code> - this package provides the implementation messagebus;</li> <li><code>dddmisc-handlers-collection</code> - this package provides implementation a collection of command\u2019s and event\u2019s handlers;</li> <li><code>dddmisc-uow</code> - This package provides the implementation pattern 'unit of work'.</li> </ul>"},{"location":"#install","title":"Install","text":""},{"location":"#use-pip","title":"Use <code>pip</code>","text":"<p><pre><code>pip install dddmisc-messagebus\n</code></pre> <pre><code>pip install dddmisc-domain\n</code></pre></p> <pre><code>pip install dddmisc-handlers-collection\n</code></pre> <pre><code>pip install dddmisc-unit-of-work\n</code></pre>"},{"location":"#use-poetry","title":"Use <code>poetry</code>","text":"<p><pre><code>poetry add dddmisc-messagebus\n</code></pre> <pre><code>poetry add dddmisc-domain\n</code></pre></p> <pre><code>poetry add dddmisc-handlers-collection\n</code></pre> <pre><code>poetry add dddmisc-unit-of-work\n</code></pre>"},{"location":"tutorial/","title":"\u0411\u044b\u0441\u0442\u0440\u044b\u0439 \u0441\u0442\u0430\u0440\u0442","text":"<p>\u0412 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a \u0431\u0443\u0434\u0435\u0442 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u0441\u0435\u0440\u0432\u0438\u0441 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0430 \u0441\u0431\u043e\u0440, \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u0435\u0440\u0441\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u043e\u043c OTP \u043a\u043e\u0434\u0430</p>"},{"location":"tutorial/#_2","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438","text":"<p>\u0414\u043b\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u043f\u0430\u043a\u0435\u0442 <code>domain</code> \u0438 \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u0432 \u043d\u0435\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0441 \u0438\u043c\u0435\u043d\u0435\u043c \u0434\u043e\u043c\u0435\u043d\u0430, \u0434\u043b\u044f \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e \u0432\u0441\u0435\u0445 \u043c\u043e\u0434\u0443\u043b\u044f\u0445 \u0434\u043e\u043c\u0435\u043d\u0430:</p> domain/__init_.py<pre><code>from d3m.core import DomainName\n\n__domain_name__ = DomainName('clients.agreement')\n</code></pre> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0448\u0430\u0433\u043e\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043e\u0440\u043d\u0435\u0432\u0443\u044e \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044c \u0434\u043e\u043c\u0435\u043d\u0430, \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u043c\u043e\u0434\u0443\u043b\u044c <code>model.py</code>. \u0414\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u043e\u0440\u043d\u0435\u0432\u043e\u0439 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0438 \u0432 \u043f\u0430\u043a\u0435\u0442\u0435 <code>d3m.domain</code> \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d \u043a\u043b\u0430\u0441\u0441 <code>RootEntity</code>.</p> domain/model.py<pre><code>from datetime import datetime\nfrom pydantic import Field\nfrom pydantic_extra_types.phone_numbers import PhoneNumber\nfrom d3m.domain import RootEntity\n\nfrom . import __domain_name__\n\n\nclass Agreement(RootEntity, domain=__domain_name__):\n    id_hash: str = Field(title='\u0425\u044d\u0448 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430')\n    phone: PhoneNumber = Field(title='\u0422\u0435\u043b\u0435\u0444\u043e\u043d \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP')\n    otp: str | None = Field(None, title='\u0425\u044d\u0448 OTP-\u043a\u043e\u0434\u0430')\n    attempts: int = Field(default=0, title='\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u0441\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430')\n    last_send_time: datetime| None = Field(None, title='\u0412\u0440\u0435\u043c\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP \u043a\u043e\u0434\u0430')\n    confirm_code: str | None = Field(None, title='\u041a\u043e\u0434 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043e\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f')\n</code></pre> <p>\u0414\u0430\u043b\u0435\u0435 \u0432\u044b\u0434\u0435\u043b\u0438\u043c \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b <code>otp</code>, <code>attempts</code>, <code>last_send_time</code> \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u0443\u044e \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044c. \u0414\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0435\u0439 \u0432 \u043f\u0430\u043a\u0435\u0442\u0435  <code>d3m.domain</code> \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d \u043a\u043b\u0430\u0441\u0441 <code>Entity</code></p> domain/model.py<pre><code>...\n\nclass OTP(Entity):\n    code_hash: str = Field(title='\u0425\u044d\u0448 OTP-\u043a\u043e\u0434\u0430')\n    attempts: int = Field(default=0, title='\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u0441\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430')\n    create_time: datetime | None = Field(title='\u0412\u0440\u0435\u043c\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP \u043a\u043e\u0434\u0430',\n                                         default_factory=lambda: datetime.now(timezone.utc))\n\n\nclass Agreement(RootEntity, domain=__domain_name__):\n    id_hash: str = Field(title='\u0425\u044d\u0448 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430')\n    phone: PhoneNumber = Field(title='\u0422\u0435\u043b\u0435\u0444\u043e\u043d \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP')\n    otp: OTP | None = Field(None, title='OTP-\u043a\u043e\u0434')\n    confirm_code: str | None = Field(None, title='\u041a\u043e\u0434 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043e\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f')\n</code></pre> <p>\u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u043c\u0435\u0442\u043e\u0434 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f OTP \u0432 \u043a\u043e\u0440\u043d\u0435\u0432\u043e\u0439 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0438: domain/model.py<pre><code>...\nfrom string import digits\nimport random\nimport hashlib\n\n\nclass OTP(Entity):\n    ...\n\n    def check_code(self, code: str):\n        ...\n\n    @classmethod\n    def build_otp_hash(cls, code: str) -&gt; str:\n        return hashlib.md5(code.encode()).hexdigest()\n\n\nclass Agreement(RootEntity, domain=__domain_name__):\n    ...\n\n    def create_otp(self) -&gt; str:\n        code = self._generate_otp_code()\n        self.otp = OTP(code_hash=OTP.build_otp_hash(code))\n        return code\n\n    @staticmethod\n    def _generate_otp_code() -&gt; str:\n        return ''.join(random.choice(digits) for _ in range(6))\n</code></pre></p> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0448\u0430\u0433\u043e\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430. \u041d\u043e \u0434\u043b\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0434\u0430\u0432\u0430\u0439\u0442\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u043c \u043a\u043b\u0430\u0441\u0441 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u043f\u043e\u0434\u043d\u0438\u043c\u0430\u0442\u044c \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u0435\u0441\u043b\u0438 OTP \u043a\u043e\u0434 \u043d\u0435 \u0432\u0435\u0440\u043d\u044b\u0439. \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u043c\u043e\u0434\u0443\u043b\u044c <code>exceptions.py</code> \u0432 \u043d\u0430\u0448\u0435\u043c \u043f\u0430\u043a\u0435\u0442\u0435 <code>domain</code>. \u041e\u0448\u0438\u0431\u043a\u0438 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0431\u0430\u0437\u043e\u0432\u044b\u043c \u043a\u043b\u0430\u0441\u0441\u043e\u043c <code>DomainError</code> \u0432 \u043f\u0430\u043a\u0435\u0442\u0435 <code>d3m.domain</code>.</p> domain/exceptions.py<pre><code>from d3m.domain import DomainError\nfrom . import __domain_name__\n\nclass BaseAgreementException(DomainError, domain=__domain_name__):\n    pass\n\n\nclass MaxAttemptsError(BaseAgreementException):\n    __template__ = '\u0418\u0441\u0447\u0435\u0440\u043f\u0430\u043d\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430'\n\n\nclass InvalidCode(BaseAgreementException):\n    __template__ = '\u041d\u0435 \u0432\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u0434 \u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043f\u044b\u0442\u043e\u043a {attempts}'\n\n\nclass OTPAlreadySendError(BaseAgreementException):\n    __template__ = 'OTP \u043a\u043e\u0434 \u0443\u0436\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d. \u041f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u0435 \u043f\u043e\u043f\u044b\u0442\u043a\u0443 \u043f\u043e\u0437\u0436\u0435.'\n\n\nclass OTPExpiredError(BaseAgreementException):\n    __template__ = '\u0421\u0440\u043e\u043a \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f OTP \u0438\u0441\u0442\u0435\u043a.'\n</code></pre> domain/model.py<pre><code>...\nfrom .exceptions import MaxAttemptsError, InvalidCode\n\nclass OTP(Entity):\n    ...\n\n    def check_code(self, code: str):\n        if self.attempts &gt;= 3:\n            raise MaxAttemptsError()\n        if self.code_hash != self.build_otp_hash(code):\n            self.attempts += 1\n            raise InvalidCode(attempts=self.attempts)\n\n    ...\n\n\nclass Agreement(RootEntity, domain=__domain_name__):\n    ...\n\n    def check_otp(self, code: str) -&gt; bool:\n        self.otp.check_code(code)\n        self.confirm_code = code\n\n    ...\n</code></pre> <p>\u0414\u0430\u043b\u0435\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u043b\u0430\u0441\u0441 \u0430\u0433\u0440\u0435\u0433\u0430\u0442\u0430 domain/model.py<pre><code>...\nimport abc\n\n...\n\n\nclass IAgreementAggr(abc.ABC):\n\n    @abc.abstractmethod\n    @property\n    def reference(self) -&gt; UUID:\n        ...\n\n    @abc.abstractmethod\n    async def send_otp(self):\n        ...\n\n    @abc.abstractmethod\n    def confirm_otp(self, code: str):\n        ...\n\n\nclass AgreementAggr(IAgreementAggr):\n\n    def __init__(self, agreement: Agreement) -&gt; None:\n        self._agreement = agreement\n\n    @property\n    def reference(self) -&gt; UUID:\n        return self._agreement.__reference__\n\n    async def send_otp(self):\n        pass\n\n    def confirm_otp(self, code: str):\n        pass\n</code></pre></p> <p>\u0414\u0430\u043b\u0435\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043c\u0435\u0442\u043e\u0434\u0430 <code>send_otp</code>, \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u043d\u0430\u043c \u043f\u043e\u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u0447\u0430\u0441\u0442\u043e\u0442\u0443 \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 SMS \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0448\u0430\u0431\u043b\u043e\u043d \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0430\u0434\u0430\u043f\u0442\u0435\u0440 \u043a \u0441\u0435\u0440\u0432\u0438\u0441\u0443 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439.</p> domain/model.py<pre><code>...\nclass IMessageAdapter(abc.ABC):\n\n    @abc.abstractmethod\n    async def send(self, phone: PhoneNumber, message: str):\n        ...\n\n\nclass AgreementAggr(IAgreementAggr):\n    _message_adapter: IMessageAdapter\n    _message_template: str\n    _resend_interval: timedelta\n\n    @classmethod\n    def bootstrap(cls, message_template: str,\n                  message_adapter: IMessageAdapter,\n                  resend_interval: timedelta = timedelta(seconds=60)):\n        cls._message_template = message_template\n        cls._resend_interval = resend_interval\n        cls._message_adapter = message_adapter\n\n    ...\n\n    async def send_otp(self):\n        now = datetime.now(timezone.utc)\n        if (self._agreement.otp is not None\n                and (now - self._agreement.otp.create_time &lt; self._resend_interval)):\n            raise OTPAlreadySendError()\n        code = self._agreement.create_otp()\n        await self._send_message(code)\n\n    async def _send_message(self, code: str):\n        message = self._message_template.format(code)\n        await self._message_adapter.send(self._agreement.phone, message)\n\n    def confirm_otp(self, code: str):\n        now = datetime.now(timezone.utc)\n        if now - self._agreement.otp.create_time &gt; self._expiration_interval:\n            raise OTPExpiredError()\n        self._agreement.check_otp(code)\n</code></pre> <p>\u041d\u0430 \u044d\u0442\u043e\u043c \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u043e.</p> <p>\u041f\u043e\u043b\u043d\u044b\u0439 \u043b\u0438\u0441\u0442\u0438\u043d\u0433 \u0444\u0430\u0439\u043b\u043e\u0432:</p> <code>domain/__init__.py</code><code>domain/model.py</code><code>domain/exceptions.py</code> <pre><code>from d3m.core import DomainName\n\n__domain_name__ = DomainName('clients.agreement')\n</code></pre> <pre><code>import abc\nimport random\nimport hashlib\nfrom uuid import UUID\nfrom string import digits\nfrom datetime import datetime, timezone, timedelta\n\nfrom pydantic import Field, ConfigDict\nfrom pydantic_extra_types.phone_numbers import PhoneNumber\nfrom d3m.domain import RootEntity, Entity\n\nfrom . import __domain_name__\nfrom .exceptions import MaxAttemptsError, InvalidCodeError, OTPAlreadySendError, OTPExpiredError\n\n\nclass OTP(Entity):\n    code_hash: str = Field(title='\u0425\u044d\u0448 OTP-\u043a\u043e\u0434\u0430')\n    attempts: int = Field(default=0, title='\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u0441\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430')\n    create_time: datetime | None = Field(title='\u0412\u0440\u0435\u043c\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP \u043a\u043e\u0434\u0430',\n                                         default_factory=lambda: datetime.now(timezone.utc))\n\n    model_config = ConfigDict(frozen=True)\n\n    def check_code(self, code: str):\n        if self.attempts &gt;= 3:\n            raise MaxAttemptsError()\n        if self.code_hash != self.build_otp_hash(code):\n            self.attempts += 1\n            raise InvalidCodeError(attempts=self.attempts)\n\n    @classmethod\n    def build_otp_hash(cls, code: str) -&gt; str:\n        return hashlib.md5(code.encode()).hexdigest()\n\n\nclass Agreement(RootEntity, domain=__domain_name__):\n    id_hash: str = Field(title='\u0425\u044d\u0448 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430')\n    phone: PhoneNumber = Field(title='\u0422\u0435\u043b\u0435\u0444\u043e\u043d \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP')\n    otp: OTP | None = Field(None, title='OTP-\u043a\u043e\u0434')\n    confirm_code: str | None = Field(None, title='\u041a\u043e\u0434 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043e\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f')\n\n    def create_otp(self) -&gt; str:\n        code = self._generate_otp_code()\n        self.otp = OTP(code_hash=OTP.build_otp_hash(code))\n        return code\n\n    @staticmethod\n    def _generate_otp_code() -&gt; str:\n        return ''.join(random.choice(digits) for _ in range(6))\n\n    def check_otp(self, code: str) -&gt; bool:\n        self.otp.check_code(code)\n\n\nclass IAgreementAggr(abc.ABC):\n\n    @abc.abstractmethod\n    @property\n    def reference(self) -&gt; UUID:\n        ...\n\n    @abc.abstractmethod\n    async def send_otp(self):\n        ...\n\n    @abc.abstractmethod\n    def confirm_otp(self, code: str) -&gt; None:\n        ...\n\n\nclass IMessageAdapter(abc.ABC):\n\n    @abc.abstractmethod\n    async def send(self, phone: PhoneNumber, message: str):\n        ...\n\n\nclass AgreementAggr(IAgreementAggr):\n    _message_adapter: IMessageAdapter\n    _message_template: str\n    _resend_interval: timedelta\n    _expiration_interval: timedelta\n\n    def __init__(self, agreement: Agreement) -&gt; None:\n        self._agreement = agreement\n\n    @classmethod\n    def bootstrap(cls, message_template: str,\n                  message_adapter: IMessageAdapter,\n                  resend_interval: timedelta = timedelta(seconds=60),\n                  expiration_interval: timedelta = timedelta(minutes=15),\n                  ):\n        cls._message_template = message_template\n        cls._resend_interval = resend_interval\n        cls._message_adapter = message_adapter\n        cls._expiration_interval = expiration_interval\n\n    @property\n    def reference(self) -&gt; UUID:\n        return self._agreement.__reference__\n\n    async def send_otp(self):\n        now = datetime.now(timezone.utc)\n        if (self._agreement.otp is not None\n                and (now - self._agreement.otp.create_time &lt; self._resend_interval)):\n            raise OTPAlreadySendError()\n        code = self._agreement.create_otp()\n        await self._send_message(code)\n\n    async def _send_message(self, code: str):\n        message = self._message_template.format(code)\n        await self._message_adapter.send(self._agreement.phone, message)\n\n    def confirm_otp(self, code: str):\n        now = datetime.now(timezone.utc)\n        if now - self._agreement.otp.create_time &gt; self._expiration_interval:\n            raise OTPExpiredError()\n        self._agreement.check_otp(code)\n</code></pre> <pre><code>from d3m.domain import DomainError\nfrom . import __domain_name__\n\n\nclass BaseAgreementException(DomainError, domain=__domain_name__):\n    pass\n\n\nclass MaxAttemptsError(BaseAgreementException):\n    __template__ = '\u0418\u0441\u0447\u0435\u0440\u043f\u0430\u043d\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043a\u043e\u0434\u0430'\n\n\nclass InvalidCodeError(BaseAgreementException):\n    __template__ = '\u041d\u0435 \u0432\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u0434 \u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043f\u044b\u0442\u043e\u043a {attempts}'\n\n\nclass OTPAlreadySendError(BaseAgreementException):\n    __template__ = 'OTP \u043a\u043e\u0434 \u0443\u0436\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d. \u041f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u0435 \u043f\u043e\u043f\u044b\u0442\u043a\u0443 \u043f\u043e\u0437\u0436\u0435.'\n\n\nclass OTPExpiredError(BaseAgreementException):\n    __template__ = '\u0421\u0440\u043e\u043a \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f OTP \u0438\u0441\u0442\u0435\u043a.'\n</code></pre>"},{"location":"tutorial/#_3","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u0433\u043e \u0441\u043b\u043e\u044f","text":"<p>\u0414\u043b\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u044b\u043c \u0441\u043b\u043e\u0435\u043c \u043d\u0430\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u043e\u043c \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0431\u0443\u0434\u0435\u0442 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0442\u044c \u0432\u044b\u0437\u043e\u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0445 \u0441\u043b\u0443\u0436\u0431\u044b \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u0433\u043e \u0441\u043b\u043e\u044f. \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u043c \u0444\u0430\u0439\u043b <code>domain/commands.py</code>.</p> <p>\u0414\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043a\u043e\u043c\u0430\u043d\u0434 \u0434\u043e\u043c\u0435\u043d\u0430 \u0432 \u043f\u0430\u043a\u0435\u0442\u0435 <code>d3m.core</code> \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 <code>DomainCommand</code>.</p> <p>domain/commands.py<pre><code>from uuid import UUID\n\nfrom pydantic import Field\nfrom pydantic_extra_types.phone_numbers import PhoneNumber\nfrom d3m.domain import DomainCommand\n\nfrom . import __domain_name__\n\n\nclass BaseAgreementCommand(DomainCommand, domain=__domain_name__):\n    pass\n\n\nclass CreateAgreement(BaseAgreementCommand):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f\n    \"\"\"\n    id_hash: str = Field(title='\u0425\u044d\u0448 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430')\n    phone: PhoneNumber = Field(title='\u0422\u0435\u043b\u0435\u0444\u043e\u043d \u043a\u043b\u0438\u0435\u043d\u0442\u0430')\n\n\nclass ConfirmAgreement(BaseAgreementCommand):\n    \"\"\"\n    \u041f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435 \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f\n    \"\"\"\n    reference: UUID = Field(title='\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u044f')\n    code: str = Field(title='\u041a\u043e\u0434 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f')\n\n\nclass SendOTP(BaseAgreementCommand):\n    \"\"\"\n    \u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 OTP \u043a\u043e\u0434\u0430\n    \"\"\"\n    reference: UUID = Field(title='\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u044f')\n</code></pre> \u0422\u0430\u043a\u0436\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u0441\u043e\u0431\u044b\u0442\u0438\u0435 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f, \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0432\u044b\u0437\u043e\u0432\u0430 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP \u043a\u043e\u0434\u0430 \u043f\u043e \u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0441\u043e\u0431\u044b\u0442\u0438\u044e domain/events.py<pre><code>from uuid import UUID\n\nfrom pydantic import Field\nfrom d3m.domain import DomainEvent\n\nfrom . import __domain_name__\n\nclass BaseAgreementEvent(DomainEvent, domain=__domain_name__):\n    pass\n\n\nclass AgreementCreated(BaseAgreementEvent):\n    reference: UUID = Field(title='\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u044f')\n</code></pre></p> <p>\u0414\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u0432 \u0410\u0433\u0440\u0435\u0433\u0430\u0442 \u043c\u0435\u0442\u043e\u0434 <code>create</code> domain/model.py<pre><code>...\n\nclass AgreementAggr(IAgreementAggr):\n    ...\n\n    @classmethod\n    def create(cls, agreement: Agreement) -&gt; IAgreementAggr:\n        agreement.create_event('AgreementCreated', reference=agreement.__reference__)\n        return cls(agreement)\n    ...\n</code></pre></p> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0448\u0430\u0433\u043e\u043c \u043e\u043f\u0438\u0448\u0435\u043c \u0441\u043b\u0443\u0436\u0431\u044b \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u0433\u043e \u0441\u043b\u043e\u044f. \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u0444\u0430\u0439\u043b <code>domain/usecases.py</code>.</p> domain/usecases.py<pre><code>from uuid import UUID\nfrom d3m.hc import HandlersCollection\nfrom d3m.uow import UnitOfWorkBuilder\n\nfrom .commands import CreateAgreement, ConfirmAgreement, SendOTP\nfrom .aggregate import IAgreementAggr\nfrom .exceptions import InvalidCodeError\n\n\nclass IAgreementRepository:\n\n    def create(self, id_hash: str, phone: PhoneNumber) -&gt; IAgreementAggr:\n        ...\n\n    async def get(self, reference: UUID) -&gt; IAgreementAggr:\n        ...\n\n\ncollection = HandlersCollection()\n\n\n@collection.register\nasync def create_agreement(cmd: CreateAgreement,\n                           uow_builder: UnitOfWorkBuilder[IAgreementRepository]):\n    async with uow_builder() as uow:\n\n        agreement = uow.repository.create(cmd.id_hash, cmd.phone)\n        await uow.apply()\n    return agreement.reference\n\n\n@collection.register\nasync def confirm_agreement(cmd: ConfirmAgreement,\n                            uow_builder: UnitOfWorkBuilder[IAgreementRepository]):\n    async with uow_builder() as uow:\n        agreement = await uow.repository.get(cmd.reference)\n        try:\n            agreement.confirm_otp(cmd.otp)\n            await uow.apply()\n        except InvalidCodeError:\n            await uow.apply()\n            raise\n\n\n@collection.subscribe('clients.agreement.AgreementCreated')\n@collection.register\nasync def send_otp(cmd: SendOTP,\n                     uow_builder: UnitOfWorkBuilder[IAgreementRepository]):\n    async with uow_builder() as uow:\n        agreement = await uow.repository.get(cmd.reference)\n        await agreement.send_otp()\n        await uow.apply()\n</code></pre> <p>\u041a\u043b\u0430\u0441\u0441 <code>d3m.hc.HandlersCollection</code> \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044e \u0432\u0441\u0435\u0445 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 \u043a\u043e\u043c\u0430\u043d\u0434 \u0438 \u0432 \u043f\u043e\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434 \u043a \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u043c \u0441\u043b\u0443\u0436\u0431\u0430\u043c \u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u043e\u043c <code>d3m.messgebus.Messagebus</code>.</p> <p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043a\u043e\u043c\u0430\u043d\u0434\u044b <code>SendOTP</code> \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043f\u043e\u0434\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0435 \u043f\u043e\u0434\u043d\u044f\u0442\u043e\u0435 \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 OTP \u043a\u043e\u0434\u0430.</p>"},{"location":"tutorial/#_4","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u043e\u0433\u043e \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u0434\u0430\u043d\u043d\u044b\u0445","text":"<p>\u041f\u0430\u043a\u0435\u0442\u043e\u043c <code>d3m.uow</code> \u043f\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u043e\u0432 <code>UnitOfWorkBuilder</code>, <code>UnitOfWorkCtxMgr</code>, <code>UnitOfWork</code>, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u044b \u043a\u043b\u0430\u0441\u0441\u043e\u0432 <code>IRepository</code>, <code>IRepositoryBuilder</code>, <code>ILocker</code>.</p> <p>\u0414\u043b\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u044e\u0449\u0438\u0439 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 <code>IRepository</code> \u0438 \u043a\u043b\u0430\u0441\u0441 <code>RepositoryBuilder</code></p> repository.py<pre><code>import abc\nfrom typing import Generic, TypeVar, Any\n\nfrom d3m.core import get_running_messagebus\nfrom d3m.uow import IRepository, IRepositoryBuilder, IUnitOfWorkCtxMgr\nfrom d3m.domain import RootEntity\n\nT = TypeVar('T', bound=RootEntity)\n\n\nclass BaseRepository(IRepository, Generic[T], abc.ABC):\n    def __init__(self, engine):\n        self._engine = engine\n        self._insert_seen: dict[Any, T] = {}\n        self._update_seen: dict[Any, T] = {}\n\n    async def commit(self) -&gt; None:\n        new_updated_seen = {}\n        async with self._engine.begin() as connection:\n            for reference, entity in self._insert_seen.items():\n                await self._insert_entity(entity, connection)\n                new_updated_seen[reference] = entity\n            for reference, entity in self._insert_seen.items():\n                await self._update_entity(entity, connection)\n                new_updated_seen[reference] = entity\n            self._publish_event(*new_updated_seen.values())\n\n        self._update_seen = new_updated_seen\n        self._insert_seen.clear()\n\n    @staticmethod\n    def _publish_event(*entities: T):\n        messagebus = get_running_messagebus()\n        for entity in entities:\n            for event in entity.collecte_events():\n                _ = messagebus.handle_message(event)\n\n    @abc.abstractmethod\n    async def _insert_entity(self, entity: T, connection):\n        ...\n\n    @abc.abstractmethod\n    async def _update_entity(self, entity: T, connection):\n        ...\n\n\nclass RepositoryBuilder(IRepositoryBuilder):\n\n    def __init__(self, repository_class: type[BaseRepository], engine):\n        self._repository_class = repository_class\n        self._engine = engine\n\n    async def __call__(self, __uow_context_manager: IUnitOfWorkCtxMgr, /) -&gt; IRepository:\n        return self._repository_class(engine=self._engine)\n</code></pre> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0448\u0430\u0433\u043e\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430 <code>Agreement</code>: repository.py<pre><code>...\nclass AgreementRepository(IAgreementRepository, BaseRepository[Agreement]):\n\n    def create(self, id_hash: str, phone: PhoneNumber) -&gt; IAgreementAggr:\n        agreement = Agreement(id_hash, phone)\n        self._insert_seen[agreement.__reference__] = agreement\n        return AgreementAggr.create(agreement)\n\n    async def get(self, reference: UUID) -&gt; IAgreementAggr:\n        if reference in self._insert_seen:\n            return AgreementAggr(self._insert_seen[reference])\n        elif reference in self._update_entity:\n            return AgreementAggr(self._update_seen[reference])\n\n        async with self._engine.begin() as connection:\n            agreement = await self._get_agreement(reference, connection)\n        self._update_seen[reference] = agreement\n        return AgreementAggr(agreement)\n\n    async def _insert_entity(self, entity: T, connection):\n        ...\n\n    async def _update_entity(self, entity: T, connection):\n        ...\n\n    async def _get_agreement(self, reference, connection) -&gt; T:\n        ...\n</code></pre></p> <p>\u0414\u043b\u044f \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u044f \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u043f\u0438\u0441\u0430\u0442\u044c \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0438 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0438\u043c\u043f\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 <code>_insert_entity</code>, <code>_update_entity</code>, <code>_get_agreement</code>.</p>"},{"location":"tutorial/#api","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f API \u0441\u043b\u043e\u044f","text":"gateway.py<pre><code>from uuid import UUID\nfrom fastapi import FastAPI, APIRouter, Request\nfrom pydantic import BaseModel, Field\nfrom d3m.core import get_running_messagebus\nfrom d3m.messagebus import UniversalMessage\n\napp = FastAPI()\n\nrouter = APIRouter(prefix='/v1/agreement')\n\n\nclass CreateAgreementResponse(BaseModel):\n    reference: UUID\n\n\n@router.post('/')\nasync def create_agreement(request: Request) -&gt; CreateAgreementResponse:\n    mb = get_running_messagebus()\n    cmd = UniversalMessage('clients.agreement.CreateAgreement', 'COMMAND', await request.json())\n    reference = await mb.handle_message(cmd)\n    return CreateAgreementResponse(reference=reference)\n\n\nclass ConfirmAgreementRequest(BaseModel):\n    code: str = Field(title='\u041a\u043e\u0434 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f')\n\n\n@router.post('/{reference}')\nasync def confirm_agreement(body: ConfirmAgreementRequest, reference: UUID) -&gt; BaseModel:\n    mb = get_running_messagebus()\n    cmd = UniversalMessage('clients.agreement.ConfirmAgreement', 'COMMAND', {'reference': reference, 'code': body.code})\n    await mb.handle_message(cmd)\n    return BaseModel()\n\n\n@router.post('/{reference}/resend')\nasync def resend_agreement(reference: UUID) -&gt; BaseModel:\n    mb = get_running_messagebus()\n    cmd = UniversalMessage('clients.agreement.SendOTP', 'COMMAND', {'reference': reference})\n    await mb.handle_message(cmd)\n    return BaseModel()\n</code></pre>"},{"location":"tutorial/#_5","title":"\u0421\u0431\u043e\u0440\u043a\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430","text":"bootstrap.py<pre><code>import asyncio\nimport signal\nfrom contextlib import asynccontextmanager\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom d3m.uow import UnitOfWorkBuilder\nfrom d3m.core import get_messagebus, set_messagebus\nfrom d3m.messagebus import Messagebus\nimport uvicorn\n\nfrom .domain import __domain_name__\nfrom .repository import AgreementRepositoryBuilder, AgreementRepository\nfrom .usecases import collection\nfrom .gateway import router\n\n\nclass Settings(BaseSettings):\n    pg_url: str\n    api_host: str = '0.0.0.0'\n    api_port: str = 80\n\n\n__setting = Settings()\n\n\ndef setup_uow_builder():\n    engine = create_async_engine(__setting.pg_url)\n    repo_builder = AgreementRepositoryBuilder(AgreementRepository, engine)\n    uow_builder = UnitOfWorkBuilder(repo_builder)\n    get_messagebus().set_defaults(__domain_name__, uow_builder=uow_builder)\n\n\n@asynccontextmanager\nasync def setup_fastapi_app(_):\n    app = FastAPI()\n    app.include_router(router)\n    config = uvicorn.Config(\n        app=app,\n        host=__setting.api_host,\n        port=__setting.api_port,\n    )\n    server = uvicorn.Server(config)\n    server.config.load()\n    server.lifespan = server.config.lifespan_class(server.config)\n    await server.startup()\n    yield\n    await server.shutdown()\n\n\ndef setup_messagebus():\n    messagebus = Messagebus(lifespan=setup_fastapi_app)\n    messagebus.include_collection(collection)\n    set_messagebus(messagebus)\n\n\ndef bootstrap():\n    setup_messagebus()\n    setup_uow_builder()\n\ndef entrypoint():\n    bootstrap()\n    messagebus = get_messagebus()\n    loop = asyncio.get_event_loop()\n\n    def stop():\n        task = loop.create_task(messagebus.close())\n        task.add_done_callback(lambda x: loop.close())\n\n    loop.add_signal_handler(signal.SIGTERM, stop)\n    loop.add_signal_handler(signal.SIGINT, stop)\n    loop.add_signal_handler(signal.SIGKILL, stop)\n\n    loop.run_until_complete(messagebus.run())\n    loop.run_forever()\n\nif __name__ == '__main__':\n    entrypoint()\n</code></pre>"},{"location":"api-reference/dddmisc-core/","title":"dddmisc-core","text":""},{"location":"api-reference/dddmisc-core/#d3m.core","title":"<code>d3m.core</code>","text":""},{"location":"api-reference/dddmisc-core/#d3m.core.DomainName","title":"<code>DomainName</code>","text":"<p>             Bases: <code>str</code></p> <p>DomainName class represents a domain name string. It extends the built-in <code>str</code> class and adds validation for domain name format.</p> <p>Attributes:</p> Name Type Description <code>part_of</code> <code>Optional[DomainName]</code> <p>Gets the parent DomainName of a sub-domain.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the domain name contains disallowed symbols.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.DomainName.part_of","title":"<code>part_of</code>  <code>property</code>","text":"<p>Gets the parent DomainName of a sub-domain.</p> <p>Returns:</p> Type Description <code>Optional[DomainName]</code> <p>The parent DomainName instance or None if it's not a sub-domain.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.MessageName","title":"<code>MessageName</code>","text":"<p>             Bases: <code>str</code></p> <p>Class representing a message name.  It extends the built-in <code>str</code> class and adds validation for message name format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message name contains disallowed symbols.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.MessageType","title":"<code>MessageType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>This class represents different types of message.</p> <p>Attributes:</p> Name Type Description <code>COMMAND</code> <code>MessageType</code> <p>The command type.</p> <code>EVENT</code> <code>MessageType</code> <p>The event type.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.MessagebusEvents","title":"<code>MessagebusEvents</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>This class representing different events that can occur in a Messagebus.</p> <p>Attributes:</p> Name Type Description <code>BEFORE_RUN</code> <code>str</code> <p>Event triggered before running the Messagebus.</p> <code>AFTER_RUN</code> <code>str</code> <p>Event triggered after running the Messagebus.</p> <code>BEFORE_STOP</code> <code>str</code> <p>Event triggered before stopping the Messagebus.</p> <code>AFTER_STOP</code> <code>str</code> <p>Event triggered after stopping the Messagebus.</p> <code>BEFORE_CLOSE</code> <code>str</code> <p>Event triggered before closing the Messagebus.</p> <code>AFTER_CLOSE</code> <code>str</code> <p>Event triggered after closing the Messagebus.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessageMeta","title":"<code>IMessageMeta</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>This class is a metaclass for defining message classes. It is meant to be inherited by a message class definitions.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The name of the message domain. Should be of type DomainName.</p> <code>__message_name__</code> <code>MessageName</code> <p>The name of the message. Should be of type MessageName.</p> <code>__type__</code> <code>MessageType</code> <p>The type of the message. Should be of type MessageType.</p> <p>Methods:</p> Name Description <code>load</code> <p>Constructs a new message object.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessageMeta.__domain_name__","title":"<code>__domain_name__: DomainName</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the domain name of the message.</p> <p>Returns:</p> Name Type Description <code>DomainName</code> <code>DomainName</code> <p>The name of the message domain.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessageMeta.__message_name__","title":"<code>__message_name__: MessageName</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the name of the message.</p> <p>Returns:</p> Name Type Description <code>MessageName</code> <code>MessageName</code> <p>The name of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessageMeta.__type__","title":"<code>__type__: MessageType</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the type of the message.</p> <p>Returns:</p> Name Type Description <code>MessageType</code> <code>MessageType</code> <p>The MessageType of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessageMeta.load","title":"<code>load(payload, reference=None, timestamp=None)</code>  <code>abstractmethod</code>","text":"<p>Constructs a new message object.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>Union[Mapping, str, bytes]</code> <p>The payload of the message. Any of a dictionary, json string, or bytes.</p> required <code>reference</code> <code>Optional[UUID]</code> <p>The reference identifier of the message. If not provided, a new UUID will be generated.</p> <code>None</code> <code>timestamp</code> <code>Optional[datetime]</code> <p>The creation timestamp of the message. If not provided, the current time will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>IMessage</code> <code>IMessage</code> <p>The newly created message object.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage","title":"<code>IMessage</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Metaclass: <code>IMessageMeta</code></p> <p>Abstract base class for defining message objects.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The name of the subject area.</p> <code>__message_name__</code> <code>MessageName</code> <p>The name of the message.</p> <code>__type__</code> <code>MessageType</code> <p>The type of the message.</p> <code>__reference__</code> <code>UUID</code> <p>The identifier of the message.</p> <code>__timestamp__</code> <code>datetime</code> <p>The creation time of the message.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the message.</p> <p>Methods:</p> Name Description <code>load</code> <p>Constructs a new message object.</p> <code>to_dict</code> <p>Returns a JSON serializable dictionary of the payload.</p> <code>to_json</code> <p>Returns a JSON string representation of the payload.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__domain_name__","title":"<code>__domain_name__: DomainName</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the domain name of the message.</p> <p>Returns:</p> Name Type Description <code>DomainName</code> <code>DomainName</code> <p>The name of the message domain.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__message_name__","title":"<code>__message_name__: MessageName</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the name of the message.</p> <p>Returns:</p> Name Type Description <code>MessageName</code> <code>MessageName</code> <p>The name of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__payload__","title":"<code>__payload__: dict</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the payload of the message Returns:     dict: The payload of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__reference__","title":"<code>__reference__: UUID</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the reference of the message.</p> <p>Returns:</p> Name Type Description <code>UUID</code> <code>UUID</code> <p>The reference of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__timestamp__","title":"<code>__timestamp__: dt.datetime</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the creation time of the message</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: The creation of the message with timezone information.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.__type__","title":"<code>__type__: MessageType</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the type of the message.</p> <p>Returns:</p> Name Type Description <code>MessageType</code> <code>MessageType</code> <p>The MessageType of the message.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Converts the message's payload to a json-serializable dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representation of the message's payload.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessage.to_json","title":"<code>to_json()</code>  <code>abstractmethod</code>","text":"<p>Converts the message's payload to a json string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A json string representation of the message's payload.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.AbstractCommand","title":"<code>AbstractCommand</code>","text":"<p>             Bases: <code>IMessage</code>, <code>ABC</code></p> <p>This class represents an abstract command.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The name of the subject area.</p> <code>__message_name__</code> <code>MessageName</code> <p>The name of the message.</p> <code>__type__</code> <code>MessageType</code> <p>The type of the message.</p> <code>__reference__</code> <code>UUID</code> <p>The identifier of the message.</p> <code>__timestamp__</code> <code>datetime</code> <p>The creation time of the message.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the message.</p> <p>Methods:</p> Name Description <code>load</code> <p>Constructs a new message object.</p> <code>to_dict</code> <p>Returns a JSON serializable dictionary of the payload.</p> <code>to_json</code> <p>Returns a JSON string representation of the payload.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.AbstractCommand.__type__","title":"<code>__type__: MessageType</code>  <code>property</code>","text":"<p>Get the type of the command.</p> <p>Returns:</p> Name Type Description <code>MessageType</code> <code>MessageType</code> <p><code>MessageType.COMMAND</code>.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.AbstractEvent","title":"<code>AbstractEvent</code>","text":"<p>             Bases: <code>IMessage</code>, <code>ABC</code></p> <p>This class represents an abstract event.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The name of the subject area.</p> <code>__message_name__</code> <code>MessageName</code> <p>The name of the message.</p> <code>__type__</code> <code>MessageType</code> <p>The type of the message.</p> <code>__reference__</code> <code>UUID</code> <p>The identifier of the message.</p> <code>__timestamp__</code> <code>datetime</code> <p>The creation time of the message.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the message.</p> <p>Methods:</p> Name Description <code>load</code> <p>Constructs a new message object.</p> <code>to_dict</code> <p>Returns a JSON serializable dictionary of the payload.</p> <code>to_json</code> <p>Returns a JSON string representation of the payload.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.AbstractEvent.__type__","title":"<code>__type__: MessageType</code>  <code>property</code>","text":"<p>Get the type of the command.</p> <p>Returns:</p> Name Type Description <code>MessageType</code> <code>MessageType</code> <p>MessageType.EVENT.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.UniversalMessage","title":"<code>UniversalMessage</code>","text":"<p>             Bases: <code>IMessage</code></p> <p>A universal class for create domain's messages.</p> <p>Parameters:</p> Name Type Description Default <code>full_message_name</code> <code>str</code> <p>The full name of the message, including the domain and name.</p> required <code>message_type</code> <code>MessageType | str</code> <p>The type of the message, either as an instance of MessageType or a string representing the type.</p> required <code>payload</code> <code>dict</code> <p>The payload of the message as a dictionary.</p> required <code>reference</code> <code>UUID | None</code> <p>Optional. A UUID representing the reference of the message. If not provided, a new UUID will be generated.</p> <code>None</code> <code>timestamp</code> <code>datetime | None</code> <p>Optional. The timestamp of the message. If not provided, the current time in UTC will be used.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The domain name of the message.</p> <code>__message_name__</code> <code>MessageName</code> <p>The name of the message.</p> <code>__type__</code> <code>MessageType</code> <p>The type of the message.</p> <code>__reference__</code> <code>UUID</code> <p>The reference of the message.</p> <code>__timestamp__</code> <code>datetime</code> <p>The timestamp of the message.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the message.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Returns the payload of the message as a dictionary.</p> <code>to_json</code> <p>Returns the payload of the message as a JSON string.</p> <p>Examples:</p> <p>Create command</p> <pre><code>&gt;&gt;&gt; command = UniversalMessage('custom-domain.subdomain.CommandName', 'command', {'arg1': 123})\n&gt;&gt;&gt; command\nUniversalMessage(\"custom-domain.subdomain.CommandName\", &lt;MessageType.COMMAND: 'COMMAND'&gt;, {'arg1': 123}, UUID('a19019fc-5e55-4b4c-9620-4e1cbf01e73a'), datetime.datetime(2024, 2, 14, 11, 58, 5, 244542, tzinfo=datetime.timezone.utc)))\n&gt;&gt;&gt; assert isinstance(event, AbstractCommand)\n&gt;&gt;&gt; assert command.__domain_name__ == 'custom-domain.subdomain'\n&gt;&gt;&gt; assert command.__message_name__ == 'CommandName'\n&gt;&gt;&gt; assert command.__type__ == MessageType.COMMAND\n&gt;&gt;&gt; assert command.__payload__ == dict(arg1=123)\n&gt;&gt;&gt; assert isinstance(command.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(command.__timestamp__, datetime)\n&gt;&gt;&gt; command.to_json()\n'{\"arg1\": 123}'\n&gt;&gt;&gt; command.to_dict()\n{'arg1': 123}\n</code></pre> <p>Create event</p> <pre><code>&gt;&gt;&gt; event = UniversalMessage('custom-domain.subdomain.EventName', 'event', {'arg': \"abc\"})\n&gt;&gt;&gt; event\nUniversalMessage(\"custom-domain.subdomain.EventName\", &lt;MessageType.EVENT: 'EVENT'&gt;, {'arg1': 123}, UUID('a19019fc-5e55-4b4c-9620-4e1cbf01e73a'), datetime.datetime(2024, 2, 14, 11, 58, 5, 244542, tzinfo=datetime.timezone.utc)))\n&gt;&gt;&gt; assert isinstance(event, AbstractEvent)\n&gt;&gt;&gt; assert event.__domain_name__ == 'custom-domain.subdomain'\n&gt;&gt;&gt; assert event.__message_name__ == 'EventName'\n&gt;&gt;&gt; assert event.__type__ == MessageType.EVENT\n&gt;&gt;&gt; assert event.__payload__ == dict(arg1=123)\n&gt;&gt;&gt; assert isinstance(event.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(event.__timestamp__, datetime)\n&gt;&gt;&gt; event.to_json()\n'{\"arg\": \"abc\"}'\n&gt;&gt;&gt; event.to_dict()\n{'arg': 'abc'}\n</code></pre>"},{"location":"api-reference/dddmisc-core/#d3m.core.IDefaultDependency","title":"<code>IDefaultDependency</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class for setting default dependencies for domain command handlers.</p> <p>This class provides a method <code>set_defaults</code> that allows users to set default dependencies for command handlers associated with a specific domain.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IDefaultDependency.set_defaults","title":"<code>set_defaults(__domain, **defaults)</code>  <code>abstractmethod</code>","text":"<p>Set defaults dependencies for domain command handlers</p> <p>Parameters:</p> Name Type Description Default <code>__domain</code> <code>DomainName | str</code> required <code>**defaults</code> <code>{}</code>"},{"location":"api-reference/dddmisc-core/#d3m.core.IHandlersCollection","title":"<code>IHandlersCollection</code>","text":"<p>             Bases: <code>IDefaultDependency</code>, <code>ABC</code></p> <p>IHandlersCollection is an abstract base class that defines the interface for a collection of message handlers.</p> <p>Methods:</p> Name Description <code>get_command_handler</code> <p>Get the registered handler for a command.</p> <code>get_event_handlers</code> <p>Get the registered handlers for commands caused by an event.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IHandlersCollection.get_command_handler","title":"<code>get_command_handler(__command, /, **dependencies)</code>  <code>abstractmethod</code>","text":"<p>Get registered command's handler for the command</p> <p>Parameters:</p> Name Type Description Default <code>__command</code> <code>AbstractCommand</code> <p>domain's command object</p> required <code>dependencies</code> <p>dependencies for command's handler</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[], Coroutine]</code> <p>Callable[[], Coroutine]: command's handler.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IHandlersCollection.get_event_handlers","title":"<code>get_event_handlers(__event, /, **dependencies)</code>  <code>abstractmethod</code>","text":"<p>Get registered command's handlers for commands caused to event</p> <p>Parameters:</p> Name Type Description Default <code>__event</code> <code>AbstractEvent</code> <p>domain's event object</p> required <code>dependencies</code> <p>dependencies for the event's handlers.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Callable[[], Coroutine], ...]</code> <p>event's handlers</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IEventsOfMessagebusManager","title":"<code>IEventsOfMessagebusManager</code>","text":"<p>             Bases: <code>ABC</code></p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IEventsOfMessagebusManager.subscribe","title":"<code>subscribe(*events, listener)</code>  <code>abstractmethod</code>","text":"<p>Subscribe a listener to one or more events of messagebus</p> <p>Parameters:</p> Name Type Description Default <code>*events</code> <code>MessagebusEvents</code> <p>A variable number of MessagebusEvents objects representing the events that the listener will subscribe to.</p> <code>()</code> <code>listener</code> <code>Callable[[IMessagebus, MessagebusEvents], Coroutine]</code> <p>A callable object that takes two arguments:     1. An instance of the IMessagebus interface.     2. A MessagebusEvents object representing the event that occurred. This callable object should return a coroutine.</p> required"},{"location":"api-reference/dddmisc-core/#d3m.core.IEventsOfMessagebusManager.unsubscribe","title":"<code>unsubscribe(*events, listener)</code>  <code>abstractmethod</code>","text":"<p>Unsubscribe a listener from one or more events.</p> <p>Parameters:</p> Name Type Description Default <code>*events</code> <code>MessagebusEvents</code> <p>One or more events to unsubscribe the listener from.</p> <code>()</code> <code>listener</code> <code>Callable[[IMessagebus, MessagebusEvents], Coroutine]</code> <p>The listener to unsubscribe from the events.</p> required"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagesPublisher","title":"<code>IMessagesPublisher</code>","text":"<p>             Bases: <code>ABC</code></p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagesPublisher.handle_message","title":"<code>handle_message(message, **dependencies)</code>  <code>abstractmethod</code>","text":"<p>Handles a message and returns a future representing the completion of the message handling.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>IMessage</code> <p>The message to be handled. Must implement the <code>IMessage</code> interface.</p> required <code>**dependencies</code> <p>Additional dependencies required for handling the message.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Future</code> <p>asyncio.Future: An asyncio future representing the completion of the message handling.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus","title":"<code>IMessagebus</code>","text":"<p>             Bases: <code>IMessagesPublisher</code>, <code>IEventsOfMessagebusManager</code>, <code>IDefaultDependency</code>, <code>ABC</code></p> <p>Represents the interface for a message bus.</p> <p>Methods:</p> Name Description <code>subscribe</code> <p>Subscribe a listener to one or more events of the message bus.</p> <code>unsubscribe</code> <p>Unsubscribe a listener from one or more events of the message bus.</p> <code>run</code> <p>Run the message bus.</p> <code>run_until_complete</code> <p>Run the message bus until the execution of a specified command.</p> <code>stop</code> <p>Stop the message bus.</p> <code>close</code> <p>Close the message bus.</p> <code>is_running</code> <p>Check if the message bus is running.</p> <code>is_closed</code> <p>Check if the message bus is closed.</p> <code>include_collection</code> <p>Include a collection of handlers in the message bus.</p> <code>handle_message</code> <p>Handle a message and return a future representing the completion of the handling.</p> <code>get_context</code> <p>Get the context of the current instance.</p> <code>set_defaults</code> <p>Set defaults for the domain's command's handlers.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.close","title":"<code>close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close the messagebus. This method blocked handle any message to messagebus. This method should call before-close and after-close events subscribed listeners.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.get_context","title":"<code>get_context()</code>  <code>abstractmethod</code>","text":"<p>Get the context of the current instance.</p> <p>Returns:</p> Name Type Description <code>Context</code> <code>Context</code> <p>The context of the current environment.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.include_collection","title":"<code>include_collection(collection)</code>  <code>abstractmethod</code>","text":"<p>Include a collection of handlers.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>IHandlersCollection</code> <p>An instance of the IHandlersCollection class that contains a collection of handlers.</p> required"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.is_closed","title":"<code>is_closed()</code>  <code>abstractmethod</code>","text":"<p>Checks if the messagebus is closed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the messagebus is closed, False otherwise.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.is_running","title":"<code>is_running()</code>  <code>abstractmethod</code>","text":"<p>Check if the messagebus is running.</p> <p>This method returns a boolean value indicating whether the messagebus is currently running.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the messagebus is running, False otherwise.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.run","title":"<code>run()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Run the messagebus. This method calls before-run and after-run events subscribed listeners. This method should be idempotent behaviour.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if messagebus is closed.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.run_until_complete","title":"<code>run_until_complete(command, **dependencies)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Runs the messagebus until given command's handler execution.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AbstractCommand</code> <p>A IMessage object representing the command to be executed.</p> required <code>**dependencies</code> <code>Any</code> <p>Additional dependencies that may be required by the command.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the command execution, which may vary depending on the command.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebus.stop","title":"<code>stop()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Stops the messagebus. This method blocked handle the message to messagebus, exclude the messages generated by current messages handlers. Stops the current operation. This method should call before-stop and after-stop events subscribed listeners. This method should be idempotent call behaviour. This method return after finished all messages handlers.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebusPolicy","title":"<code>IMessagebusPolicy</code>","text":"<p>             Bases: <code>ABC</code></p> <p>This class represents an abstract policy interface for managing messagebus in a system.</p> <p>Methods:</p> Name Description <code>get_messagebus</code> <p>Get the messagebus for the current context.</p> <code>set_messagebus</code> <p>Set the messagebus for the current context.</p> <code>new_messagebus</code> <p>Create and return a new messagebus object, according to this policy's rules.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebusPolicy.get_messagebus","title":"<code>get_messagebus()</code>  <code>abstractmethod</code>","text":"<p>Get or create a messagebus for current context.</p> <p>Returns:</p> Name Type Description <code>IMessagebus</code> <code>IMessagebus</code> <p>The messagebus for current context</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebusPolicy.new_messagebus","title":"<code>new_messagebus()</code>  <code>abstractmethod</code>","text":"<p>Create and return a new messagebus object according to this policy's rules. If there's need to set this messagebus as the messagebus for the current context, <code>set_messagebus</code> must be called explicitly.</p> <p>Returns:</p> Name Type Description <code>IMessagebus</code> <code>IMessagebus</code> <p>The new messagebus instance</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IMessagebusPolicy.set_messagebus","title":"<code>set_messagebus(messagebus)</code>  <code>abstractmethod</code>","text":"<p>Set the messagebus for the current context.</p> <p>Parameters:</p> Name Type Description Default <code>messagebus</code> <code>IMessagebus | None</code> <p>The messagebus for set to current context.</p> required"},{"location":"api-reference/dddmisc-core/#d3m.core.IEntity","title":"<code>IEntity</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[_ReferenceType]</code></p> <p>Abstract base class for all entity classes.</p> <p>Attributes:</p> Name Type Description <code>__reference__</code> <code>_ReferenceType</code> <p>Property that represents the reference of the entity.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IEntity.__reference__","title":"<code>__reference__: _ReferenceType</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Property that represents the reference of the entity.</p> <p>Returns:</p> Type Description <code>_ReferenceType</code> <p>entity reference</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IRootEntity","title":"<code>IRootEntity</code>","text":"<p>             Bases: <code>IEntity[_ReferenceType]</code>, <code>ABC</code>, <code>Generic[_ReferenceType]</code></p> <p>This class represents an abstract root entity in a domain-driven design architecture. It is a base class for all root entities in the domain.</p> <p>Attributes:</p> Name Type Description <code>__reference__</code> <code>_ReferenceType</code> <p>Property that represents the reference of the root entity.</p> <code>__version__</code> <code>Version</code> <p>Property that represents the version of the root entity.</p> <code>__domain_name__</code> <code>DomainName</code> <p>Property that represents the domain name of the root entity.</p> <p>Methods:</p> Name Description <code>collect_events</code> <p>Collects domain events from the root entity and removes them after the call.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IRootEntity.__domain_name__","title":"<code>__domain_name__: DomainName</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Represents the domain name of the root entity.</p> <p>Returns:</p> Name Type Description <code>DomainName</code> <code>DomainName</code> <p>entity domain</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IRootEntity.__version__","title":"<code>__version__: Version</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Property that represents the version of the root entity.</p> <p>Returns:</p> Name Type Description <code>Version</code> <code>Version</code> <p>root entity version</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.IRootEntity.collect_events","title":"<code>collect_events()</code>  <code>abstractmethod</code>","text":"<p>Collects domain events from the root entity and removes them after the call.</p> <p>Returns:</p> Type Description <code>Iterable[AbstractEvent]</code> <p>Iterable[IMessage]: domain events</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.get_messagebus","title":"<code>get_messagebus()</code>","text":"<p>Returns the current IMessagebus instance.</p> <p>If there is a running IMessagebus instance, it returns that instance. Otherwise, it retrieves the IMessagebus instance using the get_messagebus method from the message bus policy.</p> <p>Returns:</p> Name Type Description <code>IMessagebus</code> <code>IMessagebus</code> <p>The current IMessagebus instance.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.get_running_messagebus","title":"<code>get_running_messagebus()</code>","text":"<p>Returns the running instance of the messagebus.</p> <p>Returns:</p> Name Type Description <code>IMessagebus</code> <code>IMessagebus</code> <p>The running instance of the messagebus.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is no running messagebus instance.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.new_messagebus","title":"<code>new_messagebus()</code>","text":"<p>Returns a new instance of the MessageBus class.</p> <p>This method retrieves the message bus policy using the get_messagebus_policy() function, and calls the new_messagebus() method of the policy to create a new message bus instance.</p> <p>Returns:</p> Name Type Description <code>IMessagebus</code> <p>A new instance of the MessageBus class.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.set_messagebus","title":"<code>set_messagebus(messagebus)</code>","text":"<p>Set the messagebus for the messagebus policy.</p> <p>Parameters:</p> Name Type Description Default <code>messagebus</code> <code>IMessagebus</code> <p>The message bus object to set.</p> required"},{"location":"api-reference/dddmisc-core/#d3m.core.get_messagebus_policy","title":"<code>get_messagebus_policy()</code>","text":"<p>Retrieves the messagebus policy.</p> <p>If the message bus policy is not initialized, it will be initialized first.</p> <p>Returns:</p> Name Type Description <code>IMessagebusPolicy</code> <code>IMessagebusPolicy</code> <p>The messagebus policy.</p>"},{"location":"api-reference/dddmisc-core/#d3m.core.set_messagebus_policy","title":"<code>set_messagebus_policy(policy)</code>","text":"<p>Set the messagebus policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>IMessagebusPolicy | None</code> <p>If <code>None</code>, no policy will be set. Otherwise, the specified <code>policy</code> will be set as the messagebus policy.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>policy</code> is not an instance of <code>IMessagebusPolicy</code> or <code>None</code>.</p>"},{"location":"api-reference/dddmisc-domain/","title":"dddmisc-domain","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities","title":"<code>d3m.domain.entities</code>","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.Entity","title":"<code>Entity</code>","text":"<p>             Bases: <code>IEntity</code>, <code>BaseModel</code>, <code>Generic[_ReferenceType]</code></p> <p>Class Entity</p> <p>A base class representing an entity.</p> <p>Attributes:</p> Name Type Description <code>__reference__</code> <code>_ReferenceType</code> <p>The reference of the entity.</p> <p>Examples:</p> <p>Create an entity class:</p> <pre><code>&gt;&gt;&gt; class Person(Entity):\n...     name: str\n...     surname: str\n...\n&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\")\n&gt;&gt;&gt; assert isinstance(person.__reference__, UUID)\n</code></pre> <p>by default reference type is <code>UUID</code> and default factory is <code>uuid.uuid4()</code></p> <p>Set custom reference value:</p> <pre><code>&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\", __reference__=uuid.UUID(int=1))\n&gt;&gt;&gt; assert person.__reference__ == uuid.UUID(int=1)\n</code></pre> <p>Set custom reference type:</p> <pre><code>&gt;&gt;&gt; PersonId = int\n&gt;&gt;&gt; class Person(Entity[PersonId]):\n...     name: str\n...     surname: str\n&gt;&gt;&gt; # when set custom reference type, the default factory is not set\n&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\", __reference__=1)\n&gt;&gt;&gt; assert person.__reference__ == 1\n</code></pre> <p>Set default factory:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; class Person(Entity[PersonId], default_factory=random.randrange(1, 1000000)):\n...     name: str\n...     surname: str\n&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\")\n&gt;&gt;&gt; assert isinstance(person.__reference__, int)\n&gt;&gt;&gt; assert 1 &lt;= person.__reference__ &lt; 1000000\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.Entity.__reference__","title":"<code>__reference__: _ReferenceType</code>  <code>property</code>","text":"<p>Returns the reference of the entity.</p> <p>Returns:</p> Name Type Description <code>_ReferenceType</code> <code>_ReferenceType</code> <p>The reference of the entity.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.RootEntity","title":"<code>RootEntity</code>","text":"<p>             Bases: <code>Entity</code>, <code>IRootEntity</code>, <code>Generic[_ReferenceType]</code></p> <p>RootEntity</p> <p>A root entity is a base class for domain entities that serves as the root of an aggregate.  It provides common functionality for managing events and versioning.</p> <p>Attributes:</p> Name Type Description <code>__reference__</code> <code>_ReferenceType</code> <p>the reference of the root entity.</p> <code>__domain_name__</code> <code>DomainName</code> <p>the domain name associated with the root entity</p> <code>__version__</code> <code>Version</code> <p>The current version of the root entity.</p> <p>Methods:</p> Name Description <code>create_event</code> <p>Create a domain event for this entity.</p> <code>collect_events</code> <p>Collect all the events that have been created for this entity.</p> <p>Examples:</p> <p>Set domain of root entity:</p> <pre><code>&gt;&gt;&gt; class Person(RootEntity, domain='person'):\n...     name: str\n...     surname: str\n&gt;&gt;&gt; assert Person.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\")\n&gt;&gt;&gt; assert person.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert isinstance(person.__reference__, UUID)\n&gt;&gt;&gt; assert person.__version__ == 1\n</code></pre> <p>Set custom version of root entity:</p> <pre><code>&gt;&gt;&gt; person = Person(name=\"John\", surname=\"Doe\", __version__=2)\n&gt;&gt;&gt; assert person.__version__ == 2\n</code></pre> <p>Create and collect domain events for this entity:</p> <pre><code>&gt;&gt;&gt; events = list(person.collect_events())\n&gt;&gt;&gt; assert len(events) == 0\n&gt;&gt;&gt; person.create_event('PersonCreated',\n...                     reference=person.__reference__,\n...                     name=person.name,\n...                     surname=person.surname)\n&gt;&gt;&gt; events = list(person.collect_events())\n&gt;&gt;&gt; assert len(events) == 1\n&gt;&gt;&gt; event = events[0]\n&gt;&gt;&gt; assert isinstance(event, AbstractEvent)\n&gt;&gt;&gt; assert event.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert event.__message_name__ == MessageName('PersonCreated')\n&gt;&gt;&gt; events = list(person.collect_events())\n&gt;&gt;&gt; assert len(events) == 0\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.RootEntity.__domain_name__","title":"<code>__domain_name__: DomainName</code>  <code>property</code>","text":"<p>Get the domain name associated with the current class.</p> <p>Returns:</p> Name Type Description <code>DomainName</code> <code>DomainName</code> <p>The domain name associated with the class.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.RootEntity.__version__","title":"<code>__version__: Version</code>  <code>property</code>","text":"<p>Get the current version of the root entity.</p> <p>Returns:</p> Name Type Description <code>Version</code> <code>Version</code> <p>The current version of the root entity.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.RootEntity.collect_events","title":"<code>collect_events()</code>","text":"<p>Collects and returns events from this root entity.</p> <p>Returns:</p> Type Description <code>Iterable[AbstractEvent]</code> <p>An iterable of <code>AbstractEvent</code> objects.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.RootEntity.create_event","title":"<code>create_event(__name, /, **payload)</code>","text":"<p>Create a domain event for this root entity.</p> <p>Attributes:</p> Name Type Description <code>__name</code> <code>MessageName | str</code> <p>The name of the event. Event class required be declared for domain of the root entity.</p> <code>**payload</code> <code>MessageName | str</code> <p>Additional keyword arguments to be passed as payload data for creating the event.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.entities.increment_version","title":"<code>increment_version(entity)</code>","text":"<p>Increments the version of the root entity</p> <p>Attributes:</p> Name Type Description <code>entity</code> <code>RootEntity</code> <p>The root entity object whose version needs to be incremented.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.bases","title":"<code>d3m.domain.bases</code>","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.bases.BaseDomainMessage","title":"<code>BaseDomainMessage</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>IMessage</code>, <code>ABC</code></p> <p>Class representing a base domain message.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The domain name associated with the current class.</p> <code>__message_name__</code> <code>MessageName</code> <p>The message name associated with the current class.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the message.</p> <code>__reference__</code> <code>UUID</code> <p>The unique identifier for the message.</p> <code>__timestamp__</code> <code>datetime</code> <p>The timestamp of when the message was created.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Returns a dictionary representation of the message.</p> <code>to_json</code> <p>Returns a JSON string representation of the message.</p>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.command","title":"<code>d3m.domain.command</code>","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.command.DomainCommand","title":"<code>DomainCommand</code>","text":"<p>             Bases: <code>BaseDomainMessage</code>, <code>AbstractCommand</code></p> <p>Class representing a base domain command.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The domain name associated with the current command.</p> <code>__message_name__</code> <code>MessageName</code> <p>The message name associated with the current command.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the command.</p> <code>__type__</code> <code>MessageType</code> <p>Always return <code>MessageType.COMMAND</code></p> <code>__reference__</code> <code>UUID</code> <p>The unique identifier for the command.</p> <code>__timestamp__</code> <code>datetime</code> <p>The timestamp of when the command was created.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Returns a dictionary representation payload of the command.</p> <code>to_json</code> <p>Returns a JSON string representation payload of the command.</p> <code>load</code> <p>class method returns new instance of the domain command</p> <p>Examples:</p> <p>Create command class:</p> <pre><code>&gt;&gt;&gt; from d3m.domain import DomainCommand\n&gt;&gt;&gt; class CreatePerson(DomainCommand, domain='person'):\n...     name: str\n...     surname: str\n&gt;&gt;&gt; assert CreatePerson.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert CreatePerson.__message_name__ == MessageName('CreatePerson')\n&gt;&gt;&gt; assert CreatePerson.__type__ == MessageType.COMMAND\n</code></pre> <p>Create command instance</p> <pre><code>&gt;&gt;&gt; command = CreatePerson(\n...               name='John',\n...               surname='Black'\n...           )\n&gt;&gt;&gt; assert command.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert command.__message_name__ == MessageName('CreatePerson')\n&gt;&gt;&gt; assert isinstance(command.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(command.__timestamp__, datetime)\n&gt;&gt;&gt; assert command.__payload__ == dict(name='John', surname='Black')\n&gt;&gt;&gt; assert command.name == 'John'\n&gt;&gt;&gt; assert command.surname =='Black'\n</code></pre> <p>Load command from dict</p> <pre><code>&gt;&gt;&gt; payload = dict(name='John', surname='Black')\n&gt;&gt;&gt; reference = uuid4()\n&gt;&gt;&gt; timestamp = datetime.now(timezone.utc)\n&gt;&gt;&gt; command = CreatePerson.load(payload, reference=reference, timestamp=timestamp)\n&gt;&gt;&gt; assert command.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert command.__message_name__ == MessageName('CreatePerson')\n&gt;&gt;&gt; assert command.__reference__ == reference\n&gt;&gt;&gt; assert command.__timestamp__ == timestamp\n&gt;&gt;&gt; assert command.__payload__ == payload\n</code></pre> <p>Load command from json-string</p> <pre><code>&gt;&gt;&gt; payload = '{\"name\":\"John\",\"surname\":\"Black\"}'\n&gt;&gt;&gt; command = CreatePerson.load(payload, reference=uuid4(), timestamp=datetime.now())\n&gt;&gt;&gt; assert command.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert command.__message_name__ == MessageName('CreatePerson')\n&gt;&gt;&gt; assert isinstance(command.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(command.__timestamp__, datetime)\n&gt;&gt;&gt; assert command.name == 'John'\n&gt;&gt;&gt; assert command.surname =='Black'\n</code></pre> <p>Command's payload to json serializeble dict</p> <pre><code>&gt;&gt;&gt; assert command.to_dict() == {'name': 'John', 'surname': 'Black'}\n</code></pre> <p>Command's payload to json</p> <pre><code>&gt;&gt;&gt; assert command.to_dict() == '{\"name\":\"John\",\"surname\":\"Black\"}'\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.command.get_command_class","title":"<code>get_command_class(domain, name)</code>","text":"<p>Return registered command class by domain and name</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>DomainName | str</code> <p>The domain of the event.</p> <code>name</code> <code>MessageName | str</code> <p>The name of the event.</p> <p>Returns:</p> Type Description <code>AbstractCommandMeta</code> <p>The class of the command.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from d3m.domain import DomainCommand\n&gt;&gt;&gt; class CreatePerson(DomainCommand, domain='person')\n...     name: str\n...     surname: str\n&gt;&gt;&gt; command_class = get_command_class('person', 'CreatePerson')\n&gt;&gt;&gt; assert command_class is CreatePerson\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.event","title":"<code>d3m.domain.event</code>","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.event.DomainEvent","title":"<code>DomainEvent</code>","text":"<p>             Bases: <code>BaseDomainMessage</code>, <code>AbstractEvent</code></p> <p>Class representing a base domain event.</p> <p>Attributes:</p> Name Type Description <code>__domain_name__</code> <code>DomainName</code> <p>The domain name associated with the current event.</p> <code>__message_name__</code> <code>MessageName</code> <p>The message name associated with the current event.</p> <code>__payload__</code> <code>dict</code> <p>The payload of the event.</p> <code>__type__</code> <code>MessageType</code> <p>Always return <code>MessageType.EVENT</code></p> <code>__reference__</code> <code>UUID</code> <p>The unique identifier for the event.</p> <code>__timestamp__</code> <code>datetime</code> <p>The timestamp of when the event was created.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Returns a dictionary representation payload of the event.</p> <code>to_json</code> <p>Returns a JSON string representation payload of the event.</p> <code>load</code> <p>class method returns new instance of the domain event</p> <p>Examples:</p> <p>Create event class:</p> <pre><code>&gt;&gt;&gt; from d3m.domain import DomainEvent\n&gt;&gt;&gt; class PersonCreated(DomainEvent, domain='person'):\n...     reference: UUID\n...     name: str\n...     surname: str\n&gt;&gt;&gt; assert PersonCreated.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert PersonCreated.__message_name__ == MessageName('PersonCreated')\n&gt;&gt;&gt; assert PersonCreated.__type__ == MessageType.EVENT\n</code></pre> <p>Create event instance</p> <pre><code>&gt;&gt;&gt; event = PersonCreated(\n...             reference=person.__reference__\n...             name=person.name,\n...             surname=person.surname\n...         )\n&gt;&gt;&gt; assert event.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert event.__message_name__ == MessageName('PersonCreated')\n&gt;&gt;&gt; assert isinstance(event.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(event.__timestamp__, datetime)\n&gt;&gt;&gt; assert event.__payload__ == dict(reference=person.__reference__, name=person.name, surname=person.surname)\n&gt;&gt;&gt; assert event.reference == person.__reference__\n&gt;&gt;&gt; assert event.name == person.name\n&gt;&gt;&gt; assert event.surname == person.surname\n</code></pre> <p>Load event from dict</p> <pre><code>&gt;&gt;&gt; payload = dict(\n...               reference=person.__reference__\n...               name=person.name,\n...               surname=person.surname\n...           )\n&gt;&gt;&gt; event = PersonCreated.load(payload, reference=uuid4(), timestamp=datetime.now())\n&gt;&gt;&gt; assert event.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert event.__message_name__ == MessageName('PersonCreated')\n&gt;&gt;&gt; assert isinstance(event.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(event.__timestamp__, datetime)\n&gt;&gt;&gt; assert event.__payload__ == payload\n</code></pre> <p>Load event from json-string</p> <pre><code>&gt;&gt;&gt; payload = '{\"reference\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"John\",\"surname\":\"Black\"}'\n&gt;&gt;&gt; event = PersonCreated.load(payload, reference=uuid4(), timestamp=datetime.now())\n&gt;&gt;&gt; assert event.__domain_name__ == DomainName('person')\n&gt;&gt;&gt; assert event.__message_name__ == MessageName('PersonCreated')\n&gt;&gt;&gt; assert isinstance(event.__reference__, UUID)\n&gt;&gt;&gt; assert isinstance(event.__timestamp__, datetime)\n&gt;&gt;&gt; assert event.name == 'John'\n&gt;&gt;&gt; assert event.surname =='Black'\n&gt;&gt;&gt; assert event.reference == UUID(int=1)\n</code></pre> <p>Event's payload to json serializeble dict</p> <pre><code>&gt;&gt;&gt; assert event.to_dict() == {'reference': '00000000-0000-0000-0000-000000000001', 'name': 'John', 'surname': 'Black'}\n</code></pre> <p>Event's payload to json</p> <pre><code>&gt;&gt;&gt; assert event.to_dict() == '{\"reference\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"John\",\"surname\":\"Black\"}'\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.event.get_event_class","title":"<code>get_event_class(domain, name)</code>","text":"<p>Return registered event class by domain and name</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>DomainName | str</code> <p>The domain of the event.</p> <code>name</code> <code>MessageName | str</code> <p>The name of the event.</p> <p>Returns:</p> Type Description <code>AbstractEventMeta</code> <p>The class of the event.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from d3m.domain import DomainEvent\n&gt;&gt;&gt; class PersonCreated(DomainEvent, domain='person')\n...     name: str\n...     surname: str\n&gt;&gt;&gt; event_class = get_event_class('person', 'PersonCreated')\n&gt;&gt;&gt; assert event_class is PersonCreated\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.exceptions","title":"<code>d3m.domain.exceptions</code>","text":""},{"location":"api-reference/dddmisc-domain/#d3m.domain.exceptions.DomainError","title":"<code>DomainError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Custom Exception class for domain-specific errors</p> <p>It allows for the definition of specific error messages and supports dynamic parameter substitution in the error message template.</p> <p>Attributes:</p> Name Type Description <code>__template__</code> <code>str</code> <code>__domain_name__</code> <code>DomainName</code> <p>readonly attribute retrieves the domain name associated with the current class.</p> <code>__payload__</code> <code>Mapping[str, Any]</code> <p>readonly attribute retrieves the payload (additional parameters) associated with the error.</p> <p>Examples:</p> <p>Creating a custom DomainError subclass</p> <pre><code>&gt;&gt;&gt; class MyDomainError(DomainError, domain='my-domain'):\n...     __template__ = \"An error occurred in domain '{domain}'.\"\n&gt;&gt;&gt; assert MyDomainError.__domain_name__ == DomainName('my-domain')\n</code></pre> <p>Generating error message use template</p> <pre><code>&gt;&gt;&gt; MyDomainError(domain='my-domain', foo='bar')\nMyDomainError(\"An error occurred in domain 'test'.\")\n</code></pre> <p>Get initialization error attribures</p> <pre><code>&gt;&gt;&gt; MyDomainError(domain='my-domain', foo='bar').__payload__\n{'domain': 'my-domain', 'foo': 'bar'}\n</code></pre> <p>Fail init error without template attributes</p> <pre><code>&gt;&gt;&gt; MyDomainError(foo='bar')\nTypeError: MyDomainError() missing 1 required keyword-only argument: 'domain'\n</code></pre> <p>Init with custom message, ignore template</p> <pre><code>&gt;&gt;&gt; error = MyDomainError('custom message')\n&gt;&gt;&gt; error\nMyDomainError('custom message')\n&gt;&gt;&gt; error.__payload__\n{}\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.exceptions.get_error_class","title":"<code>get_error_class(domain, name)</code>","text":"<p>Return registered error class by domain and name</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>DomainName | str</code> <p>The domain of the error.</p> <code>name</code> <code>str</code> <p>The name of the error.</p> <p>Returns:</p> Type Description <code>type[DomainError]</code> <p>The class of the error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from d3m.domain import DomainError\n&gt;&gt;&gt; class PersonNotFound(DomainError, domain='person')\n...     __template__: str = 'Person {reference} not found'\n&gt;&gt;&gt; error_class = get_error_class('person', 'PersonNotFound')\n&gt;&gt;&gt; assert error_class is PersonNotFound\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.exceptions.get_or_create_error_class","title":"<code>get_or_create_error_class(domain, name, template=None)</code>","text":"<p>Get or create a error class associated with the given domain. If base error class associated with the given domain does not exist, then create it.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str | DomainName</code> <p>The domain of the error class.</p> <code>template</code> <code>str | None</code> <p>The template for the error class. Defaults to None.</p> <p>Returns:</p> Type Description <code>type[DomainError]</code> <p>A type object representing the error class for the given domain and name.</p> <p>Examples:</p> <p>Get existing error class</p> <pre><code>&gt;&gt;&gt; class BasePersonDomainError(DomainError, domain='person'):\n...     pass\n&gt;&gt;&gt; class PersonNotFound(BasePersonDomainError):\n...     __template__ = 'Person {reference} not found'\n&gt;&gt;&gt; error_class = get_or_create_error_class(\n...     domain='person',\n...     name='PersonNotFound',\n... )\n&gt;&gt;&gt; assert error_class is PersonNotFound\n</code></pre> <p>Create new error class</p> <pre><code>&gt;&gt;&gt; class BasePersonDomainError(DomainError, domain='person'):\n...     pass\n&gt;&gt;&gt; error_class = get_or_create_error_class(\n...     domain='person',\n...     name='PersonNotFound',\n...     template='Person {reference} not found'\n... )\n&gt;&gt;&gt; assert error_class.__name__ == 'PersonNotFound'\n&gt;&gt;&gt; assert error_class.__domain_name__ = 'person'\n&gt;&gt;&gt; assert isinstance(error_class, BasePersonDomainError)\n</code></pre>"},{"location":"api-reference/dddmisc-domain/#d3m.domain.exceptions.get_or_create_base_error_class","title":"<code>get_or_create_base_error_class(domain, *, template=None)</code>","text":"<p>Get or create a base error class associated with the given domain</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str | DomainName</code> <p>The domain of the base error class.</p> <code>template</code> <code>str | None</code> <p>The template for the base error class. Defaults to None.</p> <p>Returns:     The base error class associated with the given domain, or a newly created base error class if one does not exist.</p> <p>Examples:</p> <p>Get existing base error class</p> <pre><code>&gt;&gt;&gt; class BasePersonDomainError(DomainError, domain='person'):\n...     pass\n&gt;&gt;&gt; class PersonNotFound(BasePersonDomainError):\n...     __template__ = 'Person {reference} not found'\n&gt;&gt;&gt; error_class = get_or_create_base_error_class('person')\n&gt;&gt;&gt; assert error_class is BasePersonDomainError\n</code></pre> <p>Create new base error class</p> <pre><code>&gt;&gt;&gt; error_class = get_or_create_base_error_class('person')\n&gt;&gt;&gt; assert error_class.__module__ is __name__\n&gt;&gt;&gt; error_class.__name__\n'__BaseError__'\n&gt;&gt;&gt; error_class.__domain_name__\nDomainName('person')\n</code></pre>"},{"location":"api-reference/dddmisc-handlers-collection/","title":"dddmisc-handlers-collection","text":""},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc","title":"<code>d3m.hc</code>","text":""},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection","title":"<code>HandlersCollection</code>","text":"<p>             Bases: <code>IHandlersCollection</code></p> <p>Class representing a collection of command and event handlers.</p> The HandlersCollection class provides the following functionality <ul> <li>Registration and retrieval of command handlers</li> <li>Retrieval of event handlers</li> <li>Registration of event subscriptions</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the collection</p> <code>None</code> <p>Methods:</p> Name Description <code>get_command_handler</code> <p>Retrieves the command handler for the specified command.</p> <code>get_event_handlers</code> <p>Retrieves the event handlers for the specified event.</p> <code>register</code> <p>Registers a command handler.</p> <code>subscribe</code> <p>Registers an event subscription.</p> <code>set_defaults</code> <p>Sets default values for the specified domain.</p> <code>__copy__</code> <p>Creates and returns a copy of the HandlersCollection object.</p> <p>Examples:</p> <p>Init collection:</p> <pre><code>&gt;&gt;&gt; collection = HandlersCollection(name='Example')\n&gt;&gt;&gt; collection\nd3m.hc.HandlersCollection&lt;name='Example', registered_command=0, registered_events=0&gt;\n</code></pre> <p>Register command's handler:</p> <pre><code>&gt;&gt;&gt; @collection.register\n... async def command_handler1(cmd: CustomCommand1, dependencies1: int):\n...     ...\n&gt;&gt;&gt; @collection.register\n... async def command_handler2(dependencies1: int, cmd: CustomCommand2):\n...     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; collection\nd3m.hc.HandlersCollection&lt;name='Example', registered_command=2, registered_events=0&gt;\n</code></pre> <p>Handlers collection associate command with command's argument by signature type hinting!</p> <p>Subscribe to event:</p> <pre><code>&gt;&gt;&gt; @collection.subscribe('other-domain.CustomEvent')\n... @collection.register\n... async def command_handler(arg1: str, cmd: CustomCommand):\n...     return cmd.__reference__\n&gt;&gt;&gt; collection\nd3m.hc.HandlersCollection&lt;name='Example', registered_command=1, registered_events=1&gt;\n</code></pre>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection.get_command_handler","title":"<code>get_command_handler(__command, **dependencies)</code>","text":"<p>Retrieves the command handler for the specified command.</p> <p>Parameters:</p> Name Type Description Default <code>__command</code> <code>AbstractCommand</code> <p>The command to be handled.</p> required <code>**dependencies</code> <p>Additional dependencies that the command handler may require.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[], Coroutine]</code> <p>A callable that is a coroutine and represents the handler for the given command.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collection = HandlersCollection(name='Example')\n&gt;&gt;&gt; @collection.register\n... async def command_handler(arg1: str, cmd: CustomCommand):\n...     return cmd.__reference__, arg1\n&gt;&gt;&gt; cmd = CustomCommand()\n&gt;&gt;&gt; handler = collection.get_command_handler(cmd, arg1='abc')\n&gt;&gt;&gt; assert await handler() == (cmd.__reference__, 'abc')\n</code></pre>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection.get_event_handlers","title":"<code>get_event_handlers(__event, /, **dependencies)</code>","text":"<p>Retrieves the event handlers for the specified event.</p> <p>Parameters:</p> Name Type Description Default <code>__event</code> <code>AbstractEvent</code> <p>An instance of AbstractEvent representing the event.</p> required <code>**dependencies</code> <p>Additional dependencies required by the event handlers.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Callable[[], Coroutine], ...]</code> <p>A tuple of callables that represent the event handlers for the given event. Each callable is a coroutine that takes no arguments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collection = HandlersCollection(name='Example')\n&gt;&gt;&gt; @collection.subscribe('other-domain.CustomEvent')\n&gt;&gt;&gt; @collection.register\n... async def command_handler1(arg1: str, cmd: CustomCommand1):\n...     return arg1\n&gt;&gt;&gt; @collection.subscribe('other-domain.CustomEvent')\n&gt;&gt;&gt; @collection.register\n... async def command_handler2(arg2: str, cmd: CustomCommand2):\n...     return arg2\n&gt;&gt;&gt; event = UniversalMessage('other-domain.CustomEvent', 'event', {})\n&gt;&gt;&gt; handlers = collection.get_event_handlers(event, arg1='abc', arg2='xyz')\n&gt;&gt;&gt; assert len(handlers) == 2\n&gt;&gt;&gt; assert await handlers[0]() == 'abc'\n&gt;&gt;&gt; assert await handlers[1]() == 'xyz'\n</code></pre>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection.register","title":"<code>register(func)</code>","text":"<p>Registers a command handler.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Coroutine]</code> <p>A callable object that takes any number of arguments and returns a coroutine.</p> required <p>Returns:</p> Type Description <code>ICommandHandler</code> <p>An instance of <code>ICommandHandler</code> representing the registered handler.</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection.set_defaults","title":"<code>set_defaults(__domain, /, **defaults)</code>","text":"<p>Sets default values for handler's dependencies. Dependencies associated with handlers by domain and attribute name.</p> <p>Parameters:</p> Name Type Description Default <code>__domain</code> <code>str | DomainName</code> <p>The domain for which default values are being set. Can be either a string or a DomainName object.</p> required <code>**defaults</code> <p>Dependencies values for the specified domain.</p> <code>{}</code>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.HandlersCollection.subscribe","title":"<code>subscribe(full_event_name, /, *, condition=none_condition, converter=lambda payload: payload, retry=tc.retry_never, stop=tc.stop_after_attempt(1), wait=tc.wait_none())</code>","text":"<p>Registers an event subscription.</p> <p>Parameters:</p> Name Type Description Default <code>full_event_name</code> <code>str</code> <p>A string representing the full name of the event.</p> required <code>condition</code> <code>ICondition</code> <p>An instance of ICondition. (Default: none_condition)</p> <code>none_condition</code> <code>converter</code> <code>Callable[[Mapping], Mapping]</code> <p>A Callable object using for conversion event's payload to command's payload. Can used as Anti-coraption layer between events from other domain. (Default: lambda payload: payload)</p> <code>lambda payload: payload</code> <code>retry</code> <code>retry_base</code> <p>retry exec event's handler strategy. (Default: tenacity.retry_never)</p> <code>retry_never</code> <code>stop</code> <code>stop_base</code> <p>stop retry strategy. (Default: tenacity.stop_after_attempt(1))</p> <code>stop_after_attempt(1)</code> <code>wait</code> <code>wait_base</code> <p>wait between attempts strategy. (Default: tenacity.wait_none())</p> <code>wait_none()</code> <p>Returns:</p> Type Description <code>Callable[[ICommandHandler], ICommandHandler]</code> <p>A ICommandHandler's decorator. Not change handler behaviour.</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions","title":"<code>d3m.hc.conditions</code>","text":""},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.ICondition","title":"<code>ICondition</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base interface for conditions classes used for filter events</p> <p>Methods:</p> Name Description <code>check</code> <p>Checks the event against the specified condition</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True when consistent, False when inconsistent</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.ICondition.check","title":"<code>check(event)</code>  <code>abstractmethod</code>","text":"<p>Checks the event against the specified condition</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AbstractEvent</code> <p>event</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> when consistent, <code>False</code> when inconsistent</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.HasAttrs","title":"<code>HasAttrs</code>","text":"<p>             Bases: <code>ICondition</code></p> <p>A condition that checks if an event has all the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>*attrs</code> <code>str</code> <p>A variable number of attribute names as strings.</p> <code>()</code> <p>Methods:</p> Name Description <code>check</code> <p>Checks if an event has all the specified attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; has_attrs = HasAttrs('attribute1', 'attribute2')\n&gt;&gt;&gt; event = MyEvent({'attribute1': 'value1', 'attribute2': 'value2', 'attribute3': 'value3'})\n&gt;&gt;&gt; has_attrs.check(event)\nTrue\n</code></pre>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.And","title":"<code>And</code>","text":"<p>             Bases: <code>ICondition</code></p> <p>\"And\" condition.</p> <p>A class representing a logical AND condition.</p> <p>Parameters:</p> Name Type Description Default <code>*conditions</code> <code>ICondition</code> <p>Initializes an And instance with the given conditions.</p> <code>()</code> <p>Methods:</p> Name Description <code>check</code> <p>Checks if an event against all the specified conditions</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.Or","title":"<code>Or</code>","text":"<p>             Bases: <code>ICondition</code></p> <p>\"Or\" condition.</p> <p>A class representing a logical OR condition.</p> <p>Parameters:</p> Name Type Description Default <code>*conditions</code> <code>ICondition</code> <p>Initializes an Or instance with the given conditions.</p> <code>()</code> <p>Methods:</p> Name Description <code>check</code> <p>Checks if an event against any the specified conditions</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.Not","title":"<code>Not</code>","text":"<p>             Bases: <code>ICondition</code></p> <p>This class represents a logical NOT condition that can be used to negate the result of another condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>ICondition</code> <p>The condition to be negated.</p> required <p>Methods:</p> Name Description <code>check</code> <p>Checks if an event not against the specified condition</p>"},{"location":"api-reference/dddmisc-handlers-collection/#d3m.hc.conditions.Equal","title":"<code>Equal</code>","text":"<p>             Bases: <code>ICondition</code></p> <p>Class representing an 'Equal' condition.</p> <p>This class implements the 'ICondition' interface and provides a way to check if certain attributes in an event's payload are equal to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>**attrs</code> <p>A containing the attributes and values to check.</p> <code>{}</code> <p>Methods:</p> Name Description <code>check</code> <p>Checks if the attributes in the event's payload are equal to the specified values.</p>"},{"location":"api-reference/dddmisc-messagebus/","title":"dddmisc-messagebus","text":""},{"location":"api-reference/dddmisc-messagebus/#d3m.messagebus","title":"<code>d3m.messagebus</code>","text":"<p>Realisation EDA for DDD projects</p>"},{"location":"api-reference/dddmisc-messagebus/#d3m.messagebus.Messagebus","title":"<code>Messagebus</code>","text":"<p>             Bases: <code>IMessagebus</code></p> <p>d3m.core.IMessagebus implementation</p> <p>Parameters:</p> Name Type Description Default <code>lifespan</code> <code>Lifespan[_MessagebusT] | None</code> <p>async context manager entered when first run and exit after close</p> <code>None</code> <p>Methods:</p> Name Description <code>subscribe</code> <p>Subscribe a listener to one or more events of the message bus.</p> <code>unsubscribe</code> <p>Unsubscribe a listener from one or more events of the message bus.</p> <code>run</code> <p>Run the message bus.</p> <code>run_until_complete</code> <p>Run the message bus until the execution of a specified command.</p> <code>stop</code> <p>Stop the message bus.</p> <code>close</code> <p>Close the message bus.</p> <code>is_running</code> <p>Check if the message bus is running.</p> <code>is_closed</code> <p>Check if the message bus is closed.</p> <code>include_collection</code> <p>Include a collection of handlers in the message bus.</p> <code>handle_message</code> <p>Handle a message and return a future representing the completion of the handling.</p> <code>get_context</code> <p>Get the context of the current instance.</p> <code>set_defaults</code> <p>Set defaults for the domain's command's handlers.</p>"},{"location":"api-reference/dddmisc-messagebus/#d3m.messagebus.MessagebusPolicy","title":"<code>MessagebusPolicy</code>","text":"<p>             Bases: <code>IMessagebusPolicy</code></p> <p>Default policy implementation for accessing the messagebus.</p> <p>In this policy, each thread has its own messagebus. However, we only automatically create a messagebus by default for the main thread; other threads by default have no event loop.</p> <p>Other policies may have different rules (e.g. a single global messagebus, or automatically creating a messagebus per thread, or using some other notion of context to which a messagebus is associated).</p> <p>Methods:</p> Name Description <code>get_messagebus</code> <p>Get the messagebus for the current context.</p> <code>set_messagebus</code> <p>Set the messagebus for the current context.</p> <code>new_messagebus</code> <p>Create and return a new messagebus object, according to this policy's rules.</p>"},{"location":"api-reference/dddmisc-rabbitmq-events-transport/","title":"dddmisc-rabbitmq-events-transport","text":""},{"location":"api-reference/dddmisc-unit-of-work/","title":"dddmisc-unit-of-work","text":""},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow","title":"<code>d3m.uow</code>","text":""},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.ILocker","title":"<code>ILocker</code>","text":"<p>             Bases: <code>Generic[TLock]</code>, <code>ABC</code></p> <p>A generic abstract class representing a locker. This class defines the interface for creating a context manager that uses a lock key.</p> <p>Attributes:</p> Name Type Description <code>TLock</code> <p>generic type, returned on entering to async context manager building by locker instance.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Create a context manager that creates a lock on entering the context and releases it on exiting the context.</p> <p>Examples:</p> <p>To create a custom locker, subclass ILocker and implement the call method.</p> <pre><code>&gt;&gt;&gt; class RedLocker(ILocker):\n&gt;&gt;&gt;     def __call__(self, __lock_key: TLockKey = None, /) -&gt; AsyncContextManager[TLock]:\n&gt;&gt;&gt;         # implementation goes here\n</code></pre>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.ILocker.__call__","title":"<code>__call__(__lock_key=None)</code>  <code>abstractmethod</code>","text":"<p>Create context manager make lock use lock key</p> <p>Parameters:</p> Name Type Description Default <code>__lock_key</code> <code>str | None</code> <p>Optional lock key</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncContextManager[TLock]</code> <p>Async context manager create lock object on enter to context and release lock on exit from context</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IRepository","title":"<code>IRepository</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract base class for repositories.</p> <p>Methods:</p> Name Description <code>commit</code> <p>Commits the current state of the repository to the persistence storage.</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IRepository.commit","title":"<code>commit()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Commit all changes to storage</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IRepositoryBuilder","title":"<code>IRepositoryBuilder</code>","text":"<p>             Bases: <code>Generic[TRepo]</code>, <code>ABC</code></p> <p>Interface for repository builder using by unit of work context manager.</p> <p>Attributes:</p> Name Type Description <code>TRepo</code> <p>interface of repository to be built.</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IRepositoryBuilder.__call__","title":"<code>__call__(__uow_context_manager)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Build repository instance use unit of work context manager.</p> <p>Parameters:</p> Name Type Description Default <code>__uow_context_manager</code> <code>IUnitOfWorkCtxMgr</code> <p>unit of work context manager.</p> required <p>Returns:</p> Type Description <code>IRepository | TRepo</code> <p>repository class</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWork","title":"<code>IUnitOfWork</code>","text":"<p>             Bases: <code>Generic[TRepo]</code>, <code>ABC</code></p> <p>An interface representing a unit of work for a repository.</p> <p>Attributes:</p> Name Type Description <code>TRepo</code> <p>A generic type representing the repository.</p> <code>repository</code> <code>TRepo</code> <p>Returns the repository instance.</p> <p>Methods:</p> Name Description <code>apply</code> <p>Commits all changes in the repository.</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWork.repository","title":"<code>repository: TRepo</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>TRepo</code> <p>Repository instance</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWork.apply","title":"<code>apply()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Commit all changes in repository</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWorkCtxMgr","title":"<code>IUnitOfWorkCtxMgr</code>","text":"<p>             Bases: <code>Generic[TRepo, TLock]</code>, <code>ABC</code></p> <p>Abstract base class for context managers implementing unit of work pattern.</p> <p>This class allows for the creation of context managers that encapsulate a unit of work, providing methods for entering and exiting the context, as well as accessing a lock object.</p> <p>Attributes:</p> Name Type Description <code>TLock</code> <p>A generic type representing the lock object</p> <code>TRepo</code> <p>A generic type representing the repository</p> <code>lock</code> <code>TLock</code> <p>Returns the lock object returned from the locker.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Called when entering the context. Returns an instance of IUnitOfWork.</p> <code>__aexit__</code> <p>Called when exiting the context.</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWorkCtxMgr.lock","title":"<code>lock: TLock</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>TLock</code> <p>Lock object returned from locker</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWorkBuilder","title":"<code>IUnitOfWorkBuilder</code>","text":"<p>             Bases: <code>Generic[TRepo]</code>, <code>ABC</code></p> <p>Build unit of work context manager with an optional lock key.</p> <p>Parameters:</p> Name Type Description Default <code>lock_key</code> <p>The lock key used for locking the unit of work.</p> required <p>Returns:</p> Type Description <p>The unit of work context manager.</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.IUnitOfWorkBuilder.__call__","title":"<code>__call__(lock_key=None)</code>  <code>abstractmethod</code>","text":"<p>Build unit of work context manager and with lock used lock key</p> <p>Parameters:</p> Name Type Description Default <code>lock_key</code> <code>str | None</code> <p>lock key used for lock</p> <code>None</code> <p>Returns:</p> Type Description <code>IUnitOfWorkCtxMgr[TRepo, TLock]</code> <p>Unit of work context manager</p>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.UnitOfWorkBuilder","title":"<code>UnitOfWorkBuilder</code>","text":"<p>             Bases: <code>IUnitOfWorkBuilder</code>, <code>Generic[TRepo]</code></p> <p>Implementation of the IUnitOfWorkBuilder.</p> <p>This class is responsible for constructing and providing instances of Unit of Work context managers.</p> <p>Attributes:</p> Name Type Description <code>repository_builder</code> <code>IRepositoryBuilder[TRepo]</code> <p>An instance of IRepositoryBuilder[TRepo] that is used to construct repositories for the Unit of Work.</p> <code>locker</code> <code>ILocker[TLock]</code> <p>An instance of ILocker that is used to manage locks for the Unit of Work.</p> <p>Methods     call: Returns a new instance of the Unit of Work context manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class ICustomRepository:\n...     async def get_aggregate(self, reference):\n...         ...\n&gt;&gt;&gt; uow_builder = UnitOfWorkBuilder[ICustomRepository](RepositoryBuilder(), Locker())\n&gt;&gt;&gt; async with uow_builder('lock-key') as uow:\n...     aggregate = await uow.repository.get_aggregate(...)\n...     ... # change state of the aggregate.\n...     await uow.apply()\n</code></pre> <pre><code>&gt;&gt;&gt; uow_builder = UnitOfWorkBuilder[ICustomRepository](RepositoryBuilder(), Locker())\n&gt;&gt;&gt; uow_context_manager = uow_builder()\n&gt;&gt;&gt; assert isinstance(uow_context_manager, IUnitOfWorkCtxMgr)\n&gt;&gt;&gt; uow = await uow_context_manager.__aenter__()\n&gt;&gt;&gt; assert isinstance(uow, IUnitOfWork)\n</code></pre>"},{"location":"api-reference/dddmisc-unit-of-work/#d3m.uow.UnitOfWorkBuilder.__call__","title":"<code>__call__(__lock_key=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>__lock_key</code> <code>`TLockKey`</code> <p>The lock key used for locking the resources. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>IUnitOfWorkCtxMgr[TRepo, TLock]</code> <p><code>IUnitOfWorkCtxMgr[TRepo, TLock]</code>: The context manager object that handles the unit of work.</p>"}]}